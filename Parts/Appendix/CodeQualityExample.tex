\addcontentsline{toc}{section}{Appendix} % Remove this if you don't want the appendix included in the table of contents.
\appendix
\section{Code Quality Examples}
\subsection{Example 1 - Added convenience function to module}

\begin{minted}[xleftmargin=\parindent,linenos]{C}
void printNameAndAddress(int i){
    sem_wait(personSem);
    printName(i);
    printAddress(i);
    sem_signal(personSem);
}
\end{minted}
By combining module functions, the interface is no longer minimal. Continuing this trend will lead to code duplication in the module. We also get dependencies between functions in the module which increases complexity. This type of \textit{convenience} function can be justified if the convenience is great enough though!

\subsection{Example 2 - A module interface}
\begin{minted}[xleftmargin=\parindent,linenos]{C}
#ifndef PERSON_H
#define PERSON_H

typedef struct {
	char * firstName;
	char * lastName;
	char * street;
	int streetNumber;
} TPerson;

void reallocateArray(int newSize);
TPerson ** getArray();
void printName(int personNumber);
void printAddress(int personNumber);
void printNameAndAddress(int personNumber);
...
#endif
\end{minted}
\begin{itemize}
\item In line 12 encapsulation is broken by returning a module specific type.
\item In line 12 also, returning the array double pointer is really bad both from a encapsulation standpoint.
\item The function \texttt{reallocateArray()} should not be part of the interface, it too breaks encapsulation.
\end{itemize}

\subsection{Example 3 - A module interface (module named "Cost")}
\begin{minted}[xleftmargin=\parindent,linenos]{C}
#ifndef lift_cost_h
#define lift_cost_h

int calculateCost(int currentFloor, int direction, int orderedFloor, int orderedDirection);

int downCost[MAX_ELEVATORS][N_FLOORS];
int upCost[MAX_ELEVATORS][N_FLOORS];

void fillCostArrays();
void clearCosts(void);
int lowestCostFloor(int elevator);
int lowestCostDirection(int elevator);
int findBestElevator(int floor, int direction);
void designateElevators();
void clearDesignatedElevator();

int designatedElevator[N_FLOORS][2];

#endif
\end{minted}
\begin{itemize}
\item The main issue with this module "interface" is that it is not in fact an interface at all!
\item It is not evident from the interface what the responsibility of the module is.
\item It is likely that there are non-obvious dependencies between functions in the interface
\item Interface is not minimal, functions in line 4, 13, 11, 12 are overlapping. 
\item The abstraction is not consistent. The name indicates that the module calculates and manages cost but at the same time it manipulates cost arrays, finds best elevator and designates elevators too? This abstraction has low cohesion, it is not consistent.
\item The data members are not encapsulated.
\end{itemize}